###鉴于之前于 多益网络 的一次面试经历，进行反思
<h4>面试官：
基础非常重要，问的直接不存在语言，直接避免语言方面的询问，传达出来的意思是：基础是学生的重要要素，数据结构的算法处理、计算机网络、操作系统，这些必须处理好，在面试时才能有机会进入下一步。
我的问题：知识点都学但是不扎实，在存在需要转岗的情况下，相关能力不突出（面试官要求的内容）
所以建立一个文件，用于推送自己的算法练习，主要是为了多端练习以及数据不丢失。
本文件希望包含：所有算法处理、面试编程题、自己的项目设计、实习过程存在的问题（如果可以去实习的话）。

9-27-1:对于项目的理解缺失，需要更好的回忆、再次思考需要处理的一些亮点内容：如MySQL建表，Redis的使用，gin框架的使用，我说我使用了gorm，那么gorm是如何处理的数据，如何实现的功能。

##### 思路：建立一个多服务器进行数据传输的分布式业务，通过观察者模式进行服务端代码设计。流式数据传输下载存储。建立多表信息存储。

##### 动态规划思想：建立动态规划：1.状态转移方程、2.边界条件。
##### 动态规划问题类型：
重叠子问题：如果你发现算法中的子问题被重复计算多次，那么你可以使用动态规划来存储子问题的结果，避免重复计算。这种重叠子问题通常是递归算法的一个标志。
最优子结构：如果一个问题的最优解包含了其子问题的最优解，那么这个问题就具有最优子结构。在这种情况下，可以通过解决较小的子问题来构建问题的最终解。

##### 具体的类型：
最优化问题：如最长公共子序列、最短路径、背包问题等，这些问题要求找出某个最优化的标准下的最佳解。
序列问题：涉及到序列中的元素排列组合的问题，比如编辑距离、最长递增子序列等。
分割问题：需要将问题划分为更小的部分，然后合并这些部分的解来构建完整解的问题。
计数问题：需要计算满足特定条件的不同方案数量的问题。
游戏问题：涉及到两个玩家轮流行动的游戏，其中一个玩家试图最大化其得分，另一个玩家试图最小化对方得分。

动态规划（Dynamic Programming, DP）是一种解决具有重叠子问题和最优子结构特征问题的有效方法。下面是常见的几种动态规划问题类型，并给出了每种类型的问题的动态转移方程。

### 1. 最长公共子序列（Longest Common Subsequence, LCS）

**问题描述**：给定两个字符串 `X` 和 `Y`，找出它们之间的最长公共子序列的长度。

**状态定义**：设 `dp[i][j]` 表示字符串 `X` 的前 `i` 个字符和字符串 `Y` 的前 `j` 个字符的最长公共子序列的长度。

**状态转移方程**：
- 如果 `X[i-1] == Y[j-1]`，则 `dp[i][j] = dp[i-1][j-1] + 1`。
- 否则，`dp[i][j] = max(dp[i-1][j], dp[i][j-1])`。

### 2. 最长递增子序列（Longest Increasing Subsequence, LIS）

**问题描述**：给定一个整数数组 `nums`，找出其中最长递增子序列的长度。

**状态定义**：设 `dp[i]` 表示以 `nums[i]` 结尾的最长递增子序列的长度。

**状态转移方程**：
- `dp[i] = max(dp[i], dp[j] + 1)`，其中 `0 ≤ j < i` 且 `nums[j] < nums[i]`。

### 3. 背包问题（Knapsack Problem）

**问题描述**：给定一组物品，每件物品有重量 `weight` 和价值 `value`，以及一个背包的最大承重 `capacity`，求背包能装下的物品的最大总价值。

**状态定义**：设 `dp[i][w]` 表示在前 `i` 件物品中，背包容量为 `w` 时的最大价值。

**状态转移方程**：
- 如果包含第 `i` 件物品，则 `dp[i][w] = dp[i-1][w-weight[i]] + value[i]`。
- 如果不包含第 `i` 件物品，则 `dp[i][w] = dp[i-1][w]`。
- 最终 `dp[i][w] = max(dp[i-1][w-weight[i]] + value[i], dp[i-1][w])`。

### 4. 最短路径问题（Shortest Path Problem）

**问题描述**：给定一个图，求从起点到终点的最短路径。

**状态定义**：设 `dp[i][j]` 表示从节点 `i` 到节点 `j` 的最短路径长度。

**状态转移方程**：
- `dp[i][j] = min(dp[i][k] + cost[k][j])`，其中 `k` 是中间节点。

### 5. 编辑距离（Edit Distance）

**问题描述**：给定两个字符串 `word1` 和 `word2`，计算将 `word1` 转换成 `word2` 所需的最少操作次数，操作包括插入、删除和替换。

**状态定义**：设 `dp[i][j]` 表示 `word1` 的前 `i` 个字符转换成 `word2` 的前 `j` 个字符所需的最少操作次数。

**状态转移方程**：
- 如果 `word1[i-1] == word2[j-1]`，则 `dp[i][j] = dp[i-1][j-1]`。
- 否则，`dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1`。

### 6. 矩阵中的最小路径和（Minimum Path Sum in Matrix）

**问题描述**：给定一个 `m x n` 的矩阵 `grid`，计算从左上角到右下角的最小路径和，只能向右或向下移动。

**状态定义**：设 `dp[i][j]` 表示到达位置 `(i, j)` 的最小路径和。

**状态转移方程**：
- `dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]`。

### 7. 零一背包问题（0/1 Knapsack Problem）

**问题描述**：给定一组物品，每件物品有重量 `weight` 和价值 `value`，以及一个背包的最大承重 `capacity`，求背包能装下的物品的最大总价值。

**状态定义**：设 `dp[i][w]` 表示在前 `i` 件物品中，背包容量为 `w` 时的最大价值。

**状态转移方程**：
- 如果包含第 `i` 件物品，则 `dp[i][w] = dp[i-1][w-weight[i]] + value[i]`。
- 如果不包含第 `i` 件物品，则 `dp[i][w] = dp[i-1][w]`。
- 最终 `dp[i][w] = max(dp[i-1][w-weight[i]] + value[i], dp[i-1][w])`。

### 8. 完全背包问题（Unbounded Knapsack Problem）

**问题描述**：给定一组物品，每件物品有无限多的数量，每件物品有重量 `weight` 和价值 `value`，以及一个背包的最大承重 `capacity`，求背包能装下的物品的最大总价值。

**状态定义**：设 `dp[i][w]` 表示在前 `i` 件物品中，背包容量为 `w` 时的最大价值。

**状态转移方程**：
- `dp[i][w] = max(dp[i-1][w], dp[i][w-weight[i]] + value[i])`。

### 9. 最优二叉搜索树（Optimal Binary Search Tree）

**问题描述**：给定一系列关键字，构造一棵最优二叉搜索树，使得查找的代价最小。

**状态定义**：设 `dp[i][j]` 表示关键字区间 `[i, j]` 构造的最优二叉搜索树的期望查找代价。

**状态转移方程**：
- `dp[i][j] = min(dp[i][k-1] + dp[k+1][j] + sum(i, j))`，其中 `sum(i, j)` 是关键字区间 `[i, j]` 中所有关键字的概率之和。

### 总结

动态规划问题的核心在于定义合适的状态和状态转移方程。不同问题类型的状态定义和转移方程有所不同，但都有共同的特性：通过递推的方式逐步构建问题的解。理解状态定义和状态转移方程是解决动态规划问题的关键。

DP 相关题目：
排序后：5 53 55 62 63 64 70 72 91 96 121 132 198 279 300 303 304 309 322 338 357 376 377 486 647 712 746 877
排序前：70, 746, 198, 121, 303, 53, 376, 62, 63, 64, 300, 304, 91, 96, 309, 377, 279, 357, 322, 132, 338, 486, 877, 55, 647, 5, 712, 72

#### 进行二叉树相关的题目的编写，这些在DFS、BFS、图论中应用很广，必须会

/*
步骤：
1.确定递归函数的参数和返回值
2.确定终止条件
3.确定单层递归的逻辑
*/

###### 二叉树问题题目题号（孙秀洋）
...617 700 **98** 530 501 236 701 450 669 108


计划：11-16-11-17解决回溯16道题，一天八道题

回溯模板：
三部曲：
1、确定回溯函数的参数和返回值
2、确定回溯函数的终止条件
3、确定回溯搜索的遍历过程

题目包括：
77，216，17，39，40，131，93，78，90，491，46，47，51，37
难点包括：建立回溯过程、建立剪枝条件、建立树枝去重或者树层去重、set和uset

计划：11-18-11-19-解决贪心16题

计划：11-20-11-21解决动态规划